import { appTranslateFn } from "@web/core/l10n/translation";
import { registry } from "@web/core/registry";
import { getTemplate } from "@web/core/templates";
import { useService } from "@web/core/utils/hooks";
import { App, onWillUnmount, reactive, useExternalListener, useState } from "@odoo/owl";

import { BoxLayer } from '@iap_extract/components/manual_correction/box_layer';


const BOX_TYPES = ['word', 'number', 'date'];
const MIN_OVERLAP_RATIO = 0.25;  // The minimum overlap ratio required for two boxes to be considered aligned
const FIELD_TO_BOX_TYPE_MAPPING = {
    'char': 'word',
    'text': 'word',
    'html': 'word',
    'many2one': 'word',
    'integer': 'number',
    'float': 'number',
    'monetary': 'number',
    'date': 'date',
    'datetime': 'date',
};

/**
 * This is the renderer mixin of the subview that adds OCR features on the attachment
 * preview. It displays boxes that have been generated by the OCR. The user can manually
 * select boxes to fill in the fields of the record.
 * T should be a subclass of FormRenderer (e.g. invoice_extract_form.js or bank_statement_extract_form.js)
 */
export const ExtractMixinFormRenderer = (T) => class extends T {
    /**
     * @override
     */
    setup() {
        super.setup();

        /** @type {import("@mail/core/common/store_service").Store} */
        this.store = useService("mail.store");
        this.dialog = useService("dialog");
        this.orm = useService("orm");
        this.mailPopoutService = useService("mail.popout");

        this.recordModel = null; // to override in the subclass

        // This contain the record id of the fetched data.
        // It needs to be tracked as, if another record is loaded, we should fetch the data of the new record.
        this.recordId = -1;

        this.boxLayerApps = [];
        this.activeField;
        this.activeFieldEl;
        this.activeBoxType;
        this.boxes = {};
        this.skewAngles = {};
        this.isShiftPressed = false;

        // When a x2many line is created, keep it in memory so that, on the next selection of multiple boxes
        // on one of the x2many field, we can match which box belongs to which line.
        this.x2ManyLines = {};

        this.state = useState({
            visibleBoxes: {},
        });

        useExternalListener(window, "focusin", (event) => {
            const fieldWidget = event.target.closest(".o_field_widget,.o_field_cell");
            if (fieldWidget){
                this.onFocusFieldWidget(fieldWidget);
            }
        });

        useExternalListener(window, "focusout", (event) => {
            if (event.target.closest(".o_field_widget") && !this.mailPopoutService.externalWindow){
                this.onBlurFieldWidget();
            }
        });

        useExternalListener(window, "keydown", (event) => {
            if (event.key === 'Shift') {
                this.isShiftPressed = true;
            }
        });

        useExternalListener(window, "keyup", (event) => {
            if (event.key === 'Shift') {
                this.isShiftPressed = false;
            }
        });

        useExternalListener(window, "pointerdown", (event) => {
            // For date fields, a calendar popup appear and listens on the pointerdown event to hide itself when a
            // click occurs outside of it. This causes the loss of focus of the field and thus hides the boxes.
            if (this.activeField && event.target.closest('.o-mail-Attachment')) {
                event.stopImmediatePropagation();
            }
        }, { capture: true });

        onWillUnmount (() => {
            this.destroyBoxLayers();
        });
    }

    /**
     * Launch an Owl App with the box layer as root component.
     */
    createBoxLayerApp(props) {
        props.onClickBoxCallback = this.onClickBox.bind(this);
        props.onBoxesSelectionCallback = this.onBoxesSelection.bind(this);
        return new App(BoxLayer, {
            env: this.env,
            dev: this.env.debug,
            getTemplate,
            props,
            translatableAttributes: ["data-tooltip"],
            translateFn: appTranslateFn,
        });
    }

    /**
     * Renders the box layers on @element.
     * If a box layer already exists, it is re-used.
     */
    renderBoxLayers(element) {
        const proms = [];
        // In case of img
        if (element.classList.contains('img-fluid')) {
            this.destroyBoxLayers();
            const boxLayerApp = this.createBoxLayerApp({
                boxes: this.state.visibleBoxes[0] || [],
                mode: 'img',
                pageLayer: element,
            });
            proms.push(boxLayerApp.mount(element.parentElement));
            this.boxLayerApps = [boxLayerApp];
        }
        // In case of pdf
        if (element.tagName === 'IFRAME') {
            // Dynamically add css on the pdf viewer
            const pdfDocument = element.contentDocument;
            if (!pdfDocument.querySelector('head link#box_layer')) {
                const win = this.mailPopoutService.externalWindow || window;
                const boxLayerStylesheet = win.document.createElement('link');
                boxLayerStylesheet.setAttribute('id', 'box_layer');
                boxLayerStylesheet.setAttribute('rel', 'stylesheet');
                boxLayerStylesheet.setAttribute('type', 'text/css');
                boxLayerStylesheet.setAttribute('href', '/iap_extract/static/src/components/manual_correction/box_layer.css');
                pdfDocument.querySelector('head').append(boxLayerStylesheet);
            }
            const pageLayers = pdfDocument.querySelectorAll('.page');
            for (const pageLayer of pageLayers) {
                const pageNum = pageLayer.dataset['pageNumber'] - 1;
                const boxLayerApp = this.createBoxLayerApp({
                    boxes: this.state.visibleBoxes[pageNum] || [],
                    mode: 'pdf',
                    pageLayer: pageLayer,
                });
                proms.push(boxLayerApp.mount(pageLayer));
                this.boxLayerApps.push(boxLayerApp);
            }
        }
        return Promise.all(proms);
    }

    shouldRenderBoxes() {
        const thread = this.store.Thread.insert({
            id: this.props.record.resId,
            model: this.props.record.resModel,
        });
        return (
            ["waiting_validation", "validation_to_send"].includes(
                this.props.record.data.extract_state
            ) &&
            this.props.record.data.extract_attachment_id &&
            thread.message_main_attachment_id.id === this.props.record.data.extract_attachment_id.id
        );
    }

    /**
     * Renders the boxes on @attachment.
     * It also determines which boxes should be visible according to the current active field.
     */
    renderExtract(attachment) {
        if (this.shouldRenderBoxes()) {
            if (this.activeField !== undefined) {
                const dataToFetch = this.recordId !== this.props.record.resId;
                if (dataToFetch) {
                    this.orm.call(this.recordModel, 'get_boxes', [this.props.record.resId]).then((boxes) => {
                        this.recordId = this.props.record.resId;
                        this.boxes = reactive(boxes);

                        // Compute the skew angle of each page, it will be used to compute box alignment
                        const boxesPerPage = {};
                        for (const boxType of BOX_TYPES) {
                            for (const [pageNumber, pageBoxes] of Object.entries(boxes[boxType])) {
                                if (!boxesPerPage[pageNumber]) {
                                    boxesPerPage[pageNumber] = [];
                                }
                                boxesPerPage[pageNumber].push(...pageBoxes);
                            }
                        }
                        for (const [pageNumber, pageBoxes] of Object.entries(boxesPerPage)) {
                            this.skewAngles[pageNumber] = this.median(pageBoxes.map(box => box.angle));
                        }

                        this.state.visibleBoxes = this.boxes[this.activeBoxType] || {};
                        this.renderBoxLayers(attachment);
                    });
                }
                else {
                    this.state.visibleBoxes = this.boxes[this.activeBoxType] || {};
                    this.renderBoxLayers(attachment);
                }
            }
        }
    }

    /**
     * Determines the DOM element on which the boxes must be rendered, then render them.
     */
    showBoxes() {
        // Case pdf (iframe)
        const win = this.mailPopoutService.externalWindow || window;
        const iframe = win.document.querySelector('.o-mail-Attachment iframe');
        if (iframe) {
            const iframeDoc = iframe.contentDocument;
            if (iframeDoc) {
                this.renderExtract(iframe);
                return;
            }
        }
        // Case img
        const attachment = win.document.getElementById('attachment_img');
        if (attachment && attachment.complete) {
            this.renderExtract(attachment);
            return;
        }
    }

    resetActiveField() {
        this.activeField = undefined;
        this.activeBoxType = undefined;
        this.activeFieldEl = undefined;
        this.destroyBoxLayers();
    }

    destroyBoxLayers() {
        for (const boxLayerApp of this.boxLayerApps) {
            try {
                boxLayerApp.destroy();
            } catch {}
        }
        this.boxLayerApps = [];
    }

    median(arr) {
        const sortedArr = arr.slice().sort((a, b) => a - b);
        const middle = Math.floor(sortedArr.length / 2);
        if (sortedArr.length % 2 === 0) {
            return (sortedArr[middle - 1] + sortedArr[middle]) / 2;
        } else {
            return sortedArr[middle];
        }
    }

    unskewBoxes(boxes, skewAngle) {
        const unskewedBoxes = JSON.parse(JSON.stringify(boxes));

        const angleInRadians = -skewAngle * (Math.PI / 180);

        const cosAngle = Math.cos(angleInRadians);
        const sinAngle = Math.sin(angleInRadians);

        // The coordinates of the boxes are normalized within [0, 1], 0.5 represents the center of the axis
        const centerX = 0.5;
        const centerY = 0.5;

        for (const box of unskewedBoxes) {
            // Translate the box's midpoint to be relative to the page's center
            const translatedX = box.midX - centerX;
            const translatedY = box.midY - centerY;

            // Apply the rotation formula
            const rotatedX = translatedX * cosAngle - translatedY * sinAngle;
            const rotatedY = translatedX * sinAngle + translatedY * cosAngle;

            // Translate the coordinates back to the original system
            const unskewedMidX = rotatedX + centerX;
            const unskewedMidY = rotatedY + centerY;

            box.minX = unskewedMidX - box.width / 2;
            box.midX = unskewedMidX;
            box.maxX = unskewedMidX + box.width / 2;

            box.minY = unskewedMidY - box.height / 2;
            box.midY = unskewedMidY;
            box.maxY = unskewedMidY + box.height / 2;
        }
        return unskewedBoxes;
    }

    getBoxType(fullFieldName) {
        if (!fullFieldName) {
            return false;
        }
        let modelFieldType;
        if (fullFieldName.includes('.')) {
            const [parentField, fieldName] = fullFieldName.split('.');
            modelFieldType = this.props.record.data[parentField]?._config.fields[fieldName]?.type;
        }
        else {
            modelFieldType = this.props.record.fields[fullFieldName]?.type;
        }
        return FIELD_TO_BOX_TYPE_MAPPING[modelFieldType];
    }

    /**
     * Updates the field's value according to @newFieldValue.
     */
    async handleFieldChanged(field, newFieldValue) {
        if (field.type === 'many2one') {
            // Use dedicated function for currencies
            if (field.relation === 'res.currency') {
                const currencyId = await this.orm.call(
                    this.recordModel,
                    'get_currency_from_text',
                    [this.props.record.resId, newFieldValue],
                );
                if (currencyId) {
                    return { id: currencyId };
                }
                return;
            }

            // General case, perform a name search
            const results = await this.orm.call(field.relation, "name_search", [], {
                name: newFieldValue,
                operator: "ilike",
                limit: 2,
            });
            if (results.length === 1) {
                return { id: results[0][0] };
            }
            return;
        }
        return newFieldValue;
    }

    async getNewRecordValues(record, line, field, boxType) {
        const value = await this.handleFieldChanged(
            record.fields[field],
            this.getValueFromBoxes(line.boxes, boxType),
        );
        return { [field]: value };
    }

    getFullFieldName(fieldEl) {
        let fullFieldName = fieldEl.getAttribute('name');

        const parentField = fieldEl.parentElement.closest('.o_field_widget');
        if (parentField) {
            fullFieldName = `${parentField.getAttribute('name')}.${fullFieldName}`;
        }
        return fullFieldName;
    }

    getValueFromBoxes(boxes, type) {
        let newValue = boxes.map(box => box.text).join(" ");
        if (type === 'word') {
            // The words are joined with a space, but characters such as ',', '.', etc shouldn't have spaces around them
            const toReplace = {
                " .": ".",
                " ,": ",",
                " :": ":",
                "( ": "(",
                " )": ")",
                "[ ": "[",
                " ]": "]",
                " -": "-",
                "- ": "-",
            }
            for (const [pattern, replacement] of Object.entries(toReplace)) {
                newValue = newValue.replaceAll(pattern, replacement);
            }
        }
        else if (type === 'date') {
            newValue = registry.category("parsers").get("date")(newValue.split(' ')[0]);
        }
        else if (type === 'number') {
            newValue = registry.category("parsers").get("float")(newValue.split(' ')[0]);
        }
        return newValue;
    }

    isPartOfLine(line, element) {
        return this.isPartOfAxis(line, element, 'Y');
    }

    isPartOfAxis(axis, element, orientation) {
        if (axis.page != element.page) {
            return false;
        }

        const min = 'min' + orientation;
        const max = 'max' + orientation;

        const lengthAxis = axis[max] - axis[min];
        const lengthBox = element[max] - element[min];

        const overlap = Math.max(0, Math.min(axis[max], element[max]) - Math.max(axis[min], element[min]));
        return overlap / Math.min(lengthAxis, lengthBox) >= MIN_OVERLAP_RATIO;
    }

    groupBoxesByLine(boxes) {
        return this.groupBoxesByAxis(boxes, 'Y');
    }

    groupBoxesByColumn(boxes) {
        return this.groupBoxesByAxis(boxes, 'X');
    }

    groupBoxesByAxis(boxes, orientation) {
        if (!boxes.length) {
            return [];
        }

        const boxesCopy = JSON.parse(JSON.stringify(boxes));

        const min = 'min' + orientation;
        const max = 'max' + orientation;

        boxesCopy.sort((a, b) => a[min] - b[min]);

        let axes = []
        let currentAxis = {
            'boxes': [boxesCopy[0]],
            [min]: boxesCopy[0][min],
            [max]: boxesCopy[0][max],
            'page': boxesCopy[0].page,
        }

        boxesCopy.slice(1, boxesCopy.length).forEach((box) => {
            if (this.isPartOfAxis(currentAxis, box, orientation)) {
                currentAxis.boxes.push(box);
                currentAxis[min] = Math.min(currentAxis[min], box[min]);
                currentAxis[max] = Math.max(currentAxis[max], box[max]);
            } else {
                axes.push(currentAxis);
                currentAxis = {
                    'boxes': [box],
                    [min]: box[min],
                    [max]: box[max],
                    'page': box.page,
                }
            }
        });
        axes.push(currentAxis);

        const otherOrientation = orientation === 'X' ? 'Y' : 'X';
        axes.forEach((axis) => axis.boxes.sort((a, b) => a['min' + otherOrientation] - b['min' + otherOrientation]));

        return axes;
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Called when a field widget gains focus.
     * It serves as the entry point to render the boxes of the focused field.
     */
    onFocusFieldWidget(fieldWidget) {
        const fullFieldName = this.getFullFieldName(fieldWidget);
        const fieldType = this.getBoxType(fullFieldName);
        if (!fieldType) {
            this.resetActiveField();
            return;
        }

        this.activeField = fullFieldName;
        this.activeBoxType = fieldType;
        this.activeFieldEl = fieldWidget;

        this.showBoxes();
    }

    /**
     * Called when a field widget loses focus.
     * It hides all boxes.
     */
    onBlurFieldWidget() {
        this.resetActiveField();
    }

    async onClickBox(boxId, boxPage) {
        const box = this.boxes[this.activeBoxType][boxPage].find(box => box.id === boxId);
        return this.onBoxesSelection([box]);
    }

    async onBoxesSelection(boxes) {
        if (!boxes.length) {
            return;
        }

        const pageNumber = boxes[0].page;
        const unskewedBoxes = this.unskewBoxes(boxes, this.skewAngles[pageNumber]);

        let recordToUpdate;
        let fieldToUpdate;
        let newValue;

        // Used if the field is a x2many
        let parentField;
        let rowIndex;

        if (this.activeField.includes('.')) {
            [parentField, fieldToUpdate] = this.activeField.split('.');

            // Find the index of the row that is being edited
            const parentEl = this.activeFieldEl.closest('tbody');
            const childrenArray = Array.from(parentEl.children);
            rowIndex = childrenArray.indexOf(this.activeFieldEl.closest('tr'));

            recordToUpdate = this.props.record.data[parentField].records[rowIndex];
        }
        else {
            recordToUpdate = this.props.record;
            fieldToUpdate = this.activeField;
        }

        let lines = this.groupBoxesByLine(unskewedBoxes);
        let linesHandled = false;

        // If x2many field and multiple boxes selected
        if (parentField && lines.length > 1) {
            // For dates and numbers, it doesn't make sense to have multiple boxes selected on the same line.
            // So, group them by columns and use the boxes of the column that has most of them.
            if (['date', 'number'].includes(this.activeBoxType)) {
                const columns = this.groupBoxesByColumn(unskewedBoxes);
                const columnWithMostBoxes = columns.reduce((prev, current) => {
                    return (prev && prev.boxes.length > current.boxes.length) ? prev : current;
                })
                if (columnWithMostBoxes.boxes.length < boxes.length / 2) {
                    // The column should contain at least half of the selected boxes, otherwise, do nothing
                    return;
                }
                lines = this.groupBoxesByLine(columnWithMostBoxes.boxes);

                // Ensure each line contains a single box (should be the case, unless the boxes overlap)
                lines.forEach((line) => {
                    line.boxes = [line.boxes[0]];
                })
            }

            // If there are lines created by using this tool, try to match the selected boxes by checking for aligned content
            if (this.x2ManyLines[parentField]) {
                // Synchronize x2ManyLines by only keeping the lines that are still present (some could have been deleted by the user)
                this.x2ManyLines[parentField] = this.x2ManyLines[parentField].filter((x2ManyLine) => {
                    return this.props.record.data[parentField].records.some((record) => record.id === x2ManyLine.record.id);
                });

                const existingLines = this.x2ManyLines[parentField].filter((x2ManyLine) => x2ManyLine.line.page === pageNumber);
                existingLines.sort((a, b) => a.line.minY - b.line.minY);
                let i = 0;
                const updates = {};
                lines.forEach(async (line) => {
                    while (existingLines[i] && existingLines[i].line.maxY < line.minY) {
                        i++;
                    }
                    const existingLine = existingLines[i];
                    if (existingLine && this.isPartOfLine(existingLine.line, line)) {
                        linesHandled = true;
                        updates[i] = this.getValueFromBoxes(line.boxes, this.activeBoxType);
                        i++;
                    }
                    else if (this.activeBoxType === 'word' && updates[i - 1]) {
                        // Include it in the previous line, if something was matched.
                        // This is meant to handle description spanning multiple lines.
                        updates[i - 1] += " " + this.getValueFromBoxes(line.boxes, this.activeBoxType);
                    }
                });
                for (const [j, value] of Object.entries(updates)) {
                    this.handleFieldChanged(
                        existingLines[j].record.fields[fieldToUpdate],
                        value,
                    ).then((newValue) => {
                        existingLines[j].record.update({ [fieldToUpdate]: value });
                    })
                }
            }

            // For dates and numbers, if multiple boxes are selected, we create one line for each of them
            if (!linesHandled && ['date', 'number'].includes(this.activeBoxType)) {
                linesHandled = true;

                const boxType = this.activeBoxType;
                // Update the current record
                this.getNewRecordValues(recordToUpdate, lines[0], fieldToUpdate, boxType).then((recordValues) => {
                    recordToUpdate.update(recordValues);
                });
                if (!this.x2ManyLines[parentField]) {
                    this.x2ManyLines[parentField] = [];
                }
                this.x2ManyLines[parentField].push({
                    'record': recordToUpdate,
                    'line': lines[0],
                });

                // Create a new record for each additional line
                lines.slice(1, lines.length).forEach((line) => {
                    this.props.record.data[parentField].addNewRecord({ mode: 'readonly', position: 'bottom' }).then(async (newRecord) => {
                        const recordValues = await this.getNewRecordValues(newRecord, line, fieldToUpdate, boxType);
                        newRecord.update(recordValues);
                        this.x2ManyLines[parentField].push({
                            'record': newRecord,
                            'line': line,
                        });
                    });
                });
            }
        }

        if (!linesHandled) {
            if (boxes.length > 1 && ['date', 'number'].includes(this.activeBoxType)) {
                // Selection of multiple date/number boxes is only supported for x2many fields
                return;
            }
            newValue = this.getValueFromBoxes(boxes, this.activeBoxType);

            if (this.activeBoxType === 'word') {
                if (this.isShiftPressed) {
                    // When the shift key is pressed, append the value instead of overwriting
                    const currentValue = recordToUpdate.data[fieldToUpdate];
                    newValue = `${currentValue} ${newValue}`;
                }
            }
            newValue = await this.handleFieldChanged(
                recordToUpdate.fields[fieldToUpdate],
                newValue,
            );
            if (newValue) {
                recordToUpdate.update({ [fieldToUpdate]: newValue });
            }
        }

        if (this.activeBoxType === 'date') {
            // For the date fields, we want to hide the calendar tooltip
            // This is achieved by simulating an 'ESC' keypress
            this.activeFieldEl.querySelector('input').dispatchEvent(new KeyboardEvent('keydown', {
                key: 'Escape',
            }));
        }

        // Set a background that will slowly fade out to let the user know the boxes have been selected
        boxes.forEach((box) => box.backgroundFadeout = true);
        setTimeout(() => {
            boxes.forEach((box) => box.backgroundFadeout = false);
        }, 10);

    }
};
